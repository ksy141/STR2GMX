import numpy  as np
import pandas as pd
import MDAnalysis as mda
import os

class Molecule:

    def __init__(self, ag, toppar):
        assert ag.n_atoms != 0, 'AtomGroup contains no atoms.'

        newag = ag.residues[0].atoms
        self.resname = newag.resnames[0]
        self.u = mda.Merge(newag)
        self.RESIDUE = toppar.RESI[self.resname]
        self.ATOMS   = toppar.ATOMS

        name2index = {}
        index2name = {}
        for i, atom in enumerate(self.u.atoms):
            name2index[atom.name] = i
            index2name[i] = atom.name

        self.name2index = name2index
        self.index2name = index2name

        self.assign()
        #self.write()


    def assign(self):
        self.ag = self.u.atoms
        resname = self.resname

        assert np.all(self.ag.names == np.array(self.RESIDUE['names'])), 'are atoms missing in ' + resname + '?'

        self.ag.types = self.RESIDUE['types']
        self.u.add_TopologyAttr('charges', self.RESIDUE['charges'])
        
        for atom in self.ag:
            atom.mass = self.ATOMS[atom.type]['mass']
        
        self.bsorted = []
        self.asorted = []
        self.dsorted = []
        self.psorted = []
        self.isorted = []

        if 'bonds' in self.RESIDUE:
            bonds_str = np.array(self.RESIDUE['bonds']).reshape(-1)
            bonds = np.array([self.name2index[b] for b in bonds_str]).reshape(-1, 2)

            bb = []
            for i, j in bonds:
                if i > j:
                    i, j = j, i
                bb.append([i, j])

            df = pd.DataFrame(bb)
            self.bsorted = df.sort_values(by=[0,1]).to_numpy()
            self.u.add_TopologyAttr('bonds', self.bsorted)


        angles = np.array(mda.topology.guessers.guess_angles(self.u.bonds))
        if len(angles) > 0:
            df = pd.DataFrame(angles)
            self.asorted = df.sort_values(by=[1,0,2]).to_numpy()
            self.u.add_TopologyAttr('angles', self.asorted)

        dihedrals = np.array(mda.topology.guessers.guess_dihedrals(self.u.angles))
        if len(dihedrals) > 0:
            df = pd.DataFrame(dihedrals)
            self.dsorted = df.sort_values(by=[1,2,0,3]).to_numpy()
            self.u.add_TopologyAttr('dihedrals', self.dsorted)

        pairs14 = self._guess_pairs14(self.bsorted)
        if len(pairs14) > 0:
            self.psorted = pairs14

        if len(self.RESIDUE['imprs']) > 0:
            imprs = self.RESIDUE['imprs']
            for impr in imprs:
                atom1, atom2, atom3, atom4 = impr
                i = self.name2index[atom1]
                j = self.name2index[atom2]
                k = self.name2index[atom3]
                l = self.name2index[atom4]
                self.isorted.append([i, j, k, l])
 

    def write(self, prefix='./toppar/'):
        if not os.path.exists(prefix):
            os.makedirs(prefix)

        funcForBonds     = 1
        funcForAngles    = 5    # Urey-Bradley angle type
        funcForDihedrals = 9    # special type for treating multiple entries (modification in source code)
        funcForImpropers = 2
        funcFor14        = 1    # 1-4 interaction pair type
        funcForCmap      = 1
        funcForLonepairs = 3
        funcForExclusions = 1
        ptype = 'A'

        nrexcl = 1
        if len(self.bsorted) > 1:
            nrexcl = 2
        if len(self.dsorted) > 0:
            nrexcl = 3
        
        itpFile = open(prefix + self.resname + '.itp', 'w')
        itpFile.write(';;\n')
        itpFile.write(';; Generated by str2gmx\n')
        itpFile.write(';; A previous CHARMM-GUI script, psf2itp.py, has been used\n')
        itpFile.write(';; Correspondance:\n')
        itpFile.write(';; siyoungkim@uchicago.edu\n')
        itpFile.write(';;\n')
        itpFile.write(';; GROMACS topology file for %s\n' % self.resname.upper())
        itpFile.write(';;\n\n')
        
        itpFile.write('\n[ moleculetype ]\n')
        itpFile.write('; name\tnrexcl\n')
        itpFile.write('%s\t %5d\n' % (self.resname.upper(), nrexcl))
        

        # ATOMS
        itpFile.write('\n[ atoms ]\n')
        itpFile.write('; nr	type	resnr	residu	atom	cgnr	charge	mass\n')

        qtot = 0
        fmt = ' %5d %10s %6s %8s %6s %6d %12.6f %10.4f   ; qtot %6.3f\n'
        
        for i, atom in enumerate(self.ag):
            qtot += atom.charge
            itpFile.write(fmt %(i+1, atom.type, 1, atom.resname, atom.name, i+1, atom.charge, atom.mass, qtot))


        # BONDS
        if len(self.bsorted) > 0:
            itpFile.write('\n[ bonds ]\n')
            itpFile.write('; ai\taj\tfunct\tb0\tKb\n')
            for i, j in self.bsorted:
                itpFile.write('%5d %5d %5d\n' % (i + 1, j + 1, funcForBonds))


        # PAIRS
        if len(self.psorted) > 0:
            itpFile.write('\n[ pairs ]\n')
            itpFile.write('; ai\taj\tfunct\tc6\tc12\n')
            for i, j in self.psorted:
                itpFile.write('%5d %5d %5d\n' % (i + 1, j + 1, funcFor14))


        # ANGLES
        if len(self.asorted) > 0:
            itpFile.write('\n[ angles ] \n')
            itpFile.write('; ai\taj\tak\tfunct\tth0\tcth\tS0\tKub\n')
            for angle in self.asorted:
                i, j, k = angle
                itpFile.write('%5d %5d %5d %5d\n' % (i+1, j+1, k+1, funcForAngles))


        # DIHEDRALS
        if len(self.dsorted) > 0:
            itpFile.write('\n[ dihedrals ]\n')
            itpFile.write('; ai\taj\tak\tal\tfunct\tphi0\tcp\tmult\n')
            for dihedral in self.dsorted:
                i, j, k, l = dihedral
                itpFile.write('%5d %5d %5d %5d %5d\n' % (i+1, j+1, k+1, l+1, funcForDihedrals))


        # IMPROPER
        if len(self.isorted) > 0:
            itpFile.write('\n[ dihedrals ]\n')
            itpFile.write('; ai\taj\tak\tal\tfunct\tq0\tcq\n')
            for improper in self.isorted:
                i, j, k, l = improper
                itpFile.write('%5d %5d %5d %5d %5d\n' % (i+1, j+1, k+1, l+1, funcForImpropers))

 
#        if len(self.RESIDUE['imprs']) > 0:
#            imprs = self.RESIDUE['imprs']
#            itpFile.write('\n[ dihedrals ]\n')
#            itpFile.write('; ai\taj\tak\tal\tfunct\tq0\tcq\n')
#            for impr in imprs:
#                atom1, atom2, atom3, atom4 = impr
#                i = self.name2index[atom1]
#                j = self.name2index[atom2]
#                k = self.name2index[atom3]
#                l = self.name2index[atom4]
#                itpFile.write('%5d %5d %5d %5d %5d\n' % (i+1, j+1, k+1, l+1, funcForImpropers))
        
        
        itpFile.close()


    
    def _guess_pairs14(self, bonds):
        
        # build 1-4 pairs
        pairs14 = []
        if len(self.dsorted) == 0:
            return pairs14

        for b in bonds:
            for i in [0, 1]:
                idx1 = b[i]
                bA1l = bonds[:,0] == idx1
                bA1r = bonds[:,1] == idx1

                ids2 = np.concatenate([bonds[:,1][bA1l], bonds[:,0][bA1r]])
                if len(ids2) == 0: continue
                
                bA2l = np.isin(bonds[:,0], ids2)
                bA2r = np.isin(bonds[:,1], ids2)

                ids3 = np.concatenate([bonds[:,1][bA2l], bonds[:,0][bA2r]])
                ids3 = np.delete(ids3, np.isin(ids3, idx1))
                if len(ids3) == 0: continue
                
                bA3l = np.isin(bonds[:,0], ids3)
                bA3r = np.isin(bonds[:,1], ids3)

                ids4 = np.concatenate([bonds[:,1][bA3l], bonds[:,0][bA3r]])
                ids4 = np.delete(ids4, np.isin(ids4, ids2))
                if len(ids4) == 0: continue

                for idx4 in ids4:
                    if idx1 > idx4:
                        result = [idx4, idx1]

                    else:
                        result = [idx1, idx4]

                    if result not in pairs14:
                        pairs14.append(result)
 
        df = pd.DataFrame(pairs14)
        return df.sort_values(by=[0,1]).to_numpy()

